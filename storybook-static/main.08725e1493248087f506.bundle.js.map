{"version":3,"file":"main.08725e1493248087f506.bundle.js","sources":["webpack:///./stories/hook/DemoComponent.jsx"],"sourcesContent":["import React, { useCallback, useReducer } from 'react'\nimport PropTypes from 'prop-types'\n\nimport UsersList from '../_utils/UsersList'\nimport { reducer, initialState } from '../_utils/reducer'\nimport { fetchUsers } from '../_utils/fetchers'\nimport useInfiniteScroll from '../../src/infinite-scroll-hook/useInfiniteScroll'\n\nconst DemoComponent = ({ expectRef, offset, log }) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  const { isFetching, page, totalPages, users } = state\n\n  /**\n    * Ensure that fetchMore changes only when needed to prevent unnecessary renders\n    * https://overreacted.io/a-complete-guide-to-useeffect/#but-i-cant-put-this-function-inside-an-effect\n    */\n  const fetchMore = useCallback(() => {\n    log(page)\n    // In a real case, you should cancel the current fetch on unmount to prevent errors\n    fetchUsers(page + 1, dispatch)\n  }, [page, log])\n\n  const ref = useInfiniteScroll({\n    expectRef,\n    fetchMore,\n    ignoreScroll: isFetching || page >= totalPages,\n    offset\n  })\n\n  const props = {\n    ...expectRef && {\n      style: { height: '80vh', overflow: 'auto' },\n      ref\n    }\n  }\n\n  return (\n    <div {...props}>\n      <UsersList users={users} />\n      {isFetching &&\n        <div>Loading...</div>\n      }\n    </div>\n  )\n}\n\nDemoComponent.propTypes = {\n  expectRef: PropTypes.bool,\n  offset: PropTypes.number,\n  log: PropTypes.func.isRequired\n}\n\nDemoComponent.defaultProps = {\n  expectRef: false,\n  offset: 0\n}\n\nexport default DemoComponent\n"],"mappings":"AAwCA","sourceRoot":""}