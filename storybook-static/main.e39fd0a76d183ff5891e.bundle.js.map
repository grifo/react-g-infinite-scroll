{"version":3,"file":"main.e39fd0a76d183ff5891e.bundle.js","sources":["webpack:///./stories/component/DemoComponent.jsx"],"sourcesContent":["import React, { useCallback, useReducer } from 'react'\nimport PropTypes from 'prop-types'\n\nimport UsersList from '../_utils/UsersList'\nimport { reducer, initialState } from '../_utils/reducer'\nimport { fetchUsers } from '../_utils/fetchers'\nimport { InfiniteScroll } from '../../src'\n\nconst DemoComponent = ({ expectRef, offset, log }) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  const { isFetching, page, totalPages, users } = state\n\n  /**\n    * Ensure that fetchMore changes only when needed to prevent unnecessary renders\n    * https://overreacted.io/a-complete-guide-to-useeffect/#but-i-cant-put-this-function-inside-an-effect\n    */\n  const fetchMore = useCallback(() => {\n    log(page)\n    // In a real case, you should cancel the current fetch on unmount to prevent errors\n    fetchUsers(page + 1, dispatch)\n  }, [page, log])\n\n  const content = (\n    <>\n      <UsersList users={users} />\n      {isFetching &&\n        <div>Loading...</div>\n      }\n    </>\n  )\n\n  return (\n    <InfiniteScroll\n      expectRef={expectRef}\n      fetchMore={fetchMore}\n      ignoreScroll={isFetching || page >= totalPages}\n      offset={offset}\n    >\n      {expectRef ? ref => (\n        <div style={{ height: '80vh', overflow: 'auto' }} ref={ref}>\n          {content}\n        </div>\n      ) : (\n        content\n      )}\n    </InfiniteScroll>\n  )\n}\n\nDemoComponent.propTypes = {\n  expectRef: PropTypes.bool,\n  offset: PropTypes.number,\n  log: PropTypes.func.isRequired\n}\n\nDemoComponent.defaultProps = {\n  expectRef: false,\n  offset: 0\n}\n\nexport default DemoComponent\n"],"mappings":"AA0BA","sourceRoot":""}